safeql
======

SQL: The safe parts. Some guy favorited my tweet, so now I'm expanding. 

<blockquote class="twitter-tweet" lang="en"><p>Code Idea: SafeQL: a (not-strict) subset of SQL that has strict requirements for normalized ids, joins, selects; safe dynamic where clauses.</p>&mdash; William Laffin (@redwepainted) <a href="https://twitter.com/redwepainted/statuses/451167319784701952">April 2, 2014</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

Philosophy
----------

1. Built in, referenceable authentication. 
2. Built in, referenceable authorization.
3. Built in, referenceable schema versioning.
4. Built in, referenceable data versioning.

Opinions
--------

1. Tables must have *one* and only one ID.
2. ID's *must* be an ID type (guid, int, idc, just needs to be an id type)
3. selects cannot use comma in from.
4. all joins must be left. 
5. all inner joins must come before outer joins.
6. all cross table comparisons *must* be fk/pk based.
7. No Unions.
8. Result sets N-Dimentional by default.
9. All joins are *sets* only. (no more of this almost set theory but realy just nested for loops crap)
10. Group/where can only reference inner joins.


Example
-------

For example (syntax I just made up off the top of my head). given schema given by:

    CD:
      released Date

    Artist:
      stage_name utf8
      appears_in CD

    Producer:
      stage_name utf8
      contributed_to CD

The query:

    select 
      CD.released:
        Artist.stage_name
        Producer.stage_name
    from 
      CD
    outer join 
      Artist.appears_in
    outer join
      Producer.contributed_to 
    group by
      CD.released

would give the java equivalent of HashMap&lt;Date, List&lt;String&gt;&gt; (if your Strings are utf8 that is.. java strings are utf16.) representing the list of producers and artists that contributed to or appeared in a CD released on that date. 

TODO &amp; THOUGHTS
-------------------

1. Will have REST endpoint (equivalent of pgweb built in)
2. Will have modular structure so that safeQL and oracle dialect can use *exact same* executor and storage engines.
3. Will have referenceable compiled dynamic queries that are automatically available from schema given.
4. Will follow pdf of dbms architecture I found on the comments of the turing award article on hn.
5. Composing iterators will also have a different DSL geared toward those that want *absolte control* over execution plans.
6. There will be many kinds of indexes with storage/speed tradeoffs completely determined by user. (this necessitates a modular index architecture)
7. Dynamic sql safety will be done by limiting transaction scope in code. (generated by default, but configurable)
    using CD; Artist, Producer
    -- all sql executed will fail with security error if not from CD, Artist, Producer
    close connection
8. DDL will have many options for programatic schema declaration.
9. I want this to be the easiest DBMS to set up.
10. I want this to be the fastest DBMS to set up.
11. I want to accept all configurations of other DBMS.
12. I want to have front ends for all syntaxes other DBMS.